---
title: http协议
date: 2019-06-12
sidebar: "auto"
categories:
  - network
tags:
  - network
isShowComments: false
---

## 是什么

超文本传输协议（属于应用层协议）

## 特点

无状态，现在 cookie 解决了无状态的问题（早期网页开发时，用 cookie 解决，现在是 cookie 和 session 配合使用）

## 作用

规定了服务器和客户端传递信息的规则（统称为报文，分为：请求报文、响应报文。）

## 状态码

- 1xx : 服务器已经收到了本次请求，但是还需要进一步的处理才可以。
- 2xx : 服务器已经收到了本次请求，且已经分析、处理等........最终处理完毕！
- 3xx : 服务器已经接收到了请求，还需要其他的资源，或者重定向到其他位置，甚至交给其他服务器处理。
- 4xx ：一般指请求的参数或者地址有错误， 出现了服务器无法理解的请求（一般是前端的锅）。
- 5xx ：服务器内部错误（不是因为请求地址或者请求参数不当造成的），无法响应用户请求（一般是后端人员的锅）。

| 状态码 |                                                                  含义                                                                  |
| ------ | :------------------------------------------------------------------------------------------------------------------------------------: |
| 200    |                                                           成功（最理想状态）                                                           |
| 204    |                                          （无内容）服务器成功处理了请求，但没有返回任何内容。                                          |
| 301    | 重定向，被请求的旧资源永久移除了（不可以访问了），将会跳转到一个新资源，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址； |
| 302    |              重定向，被请求的旧资源还在（仍然可以访问），但会临时跳转到一个新资源，搜索引擎会抓取新的内容而保存旧的网址。              |
| 304    |                                               请求资源重定向到缓存中（命中了协商缓存）。                                               |
| 400    |                                                   （错误请求）服务器不理解请求的语法                                                   |
| 401    |                                 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应                                 |
| 403    |                                                        （禁止） 服务器拒绝请求                                                         |
| 404    |                                              资源未找到，一般是客户端请求了不存在的资源。                                              |
| 405    |                                                   （方法禁用） 禁用请求中指定的方法                                                    |
| 500    |                                              服务器收到了请求，但是服务器内部产生了错误。                                              |
| 502    |                  连接服务器失败（服务器在处理一个请求的时候，或许需要其他的服务器配合，但是联系不上其他的服务器了）。                  |

## http/0.9

HTTP 是基于 TCP/IP 协议的应用层协议。它不涉及数据包（packet）传输，主要规定了客户端和服务器之间的通信格式，默认使用 80 端口。
最早版本是 1991 年发布的 0.9 版。该版本极其简单，只有一个命令 GET。

```js
// 协议规定，服务器只能回应HTML格式的字符串，不能回应别的格式
// GET /index.html
```

## http/1.0

- 1996 年 5 月，HTTP/1.0 版本发布，内容大大增加。
- 首先，任何格式的内容都可以发送。这使得互联网不仅可以传输文字，还能传输图像、视频、二进制文件。这为互联网的大发展奠定了基础。
- 其次，除了 GET 命令，还引入了 POST 命令和 HEAD 命令，丰富了浏览器与服务器的互动手段。
- 再次，HTTP 请求和回应的格式也变了。除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
- 其他的新增功能还包括状态码（status code）、多字符集支持、多部分发送（multi-part type）、权限（authorization）、缓存（cache）、内容编码（content encoding）等。

- 缺点
  HTTP/1.0 版的主要缺点是，每个 TCP 连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

TCP 连接的新建成本很高，因为需要客户端和服务器三次握手，并且开始时发送速率较慢（slow start）。所以，HTTP 1.0 版本的性能比较差。随着网页加载的外部资源越来越多，这个问题就愈发突出了。

为了解决这个问题，有些浏览器在请求时，用了一个非标准的 Connection 字段。

```js
// Connection: keep-alive
```

这个字段要求服务器不要关闭 TCP 连接，以便其他请求复用。服务器同样回应这个字段。

一个可以复用的 TCP 连接就建立了，直到客户端或服务器主动关闭连接。但是，这不是标准字段，不同实现的行为可能不一致，因此不是根本的解决办法。

## http/1.1

1997 年 1 月，HTTP/1.1 版本发布，只比 1.0 版本晚了半年。它进一步完善了 HTTP 协议，一直用到了 20 年后的今天，直到现在还是最流行的版本。

1.  持久连接
    1.1 版的最大变化，就是引入了持久连接（persistent connection），即 TCP 连接默认不关闭，可以被多个请求复用，不用声明 Connection: keep-alive。

客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送 Connection: close，明确要求服务器关闭 TCP 连接。

```js
// Connection: close
```

目前，对于同一个域名，大多数浏览器允许同时建立 6 个持久连接。

2.  管道机制
    1.1 版还引入了管道机制（pipelining），即在同一个 TCP 连接里面，客户端可以同时发送多个请求。这样就进一步改进了 HTTP 协议的效率。

举例来说，客户端需要请求两个资源。以前的做法是，在同一个 TCP 连接里面，先发送 A 请求，然后等待服务器做出回应，收到后再发出 B 请求。管道机制则是允许浏览器同时发出 A 请求和 B 请求，但是服务器还是按照顺序，先回应 A 请求，完成后再回应 B 请求。

3.  Content-Length 字段
    一个 TCP 连接现在可以传送多个回应，势必就要有一种机制，区分数据包是属于哪一个回应的。这就是 Content-length 字段的作用，声明本次回应的数据长度。

```js
// Content-Length: 3495
```

上面代码告诉浏览器，本次回应的长度是 3495 个字节，后面的字节就属于下一个回应了。

在 1.0 版中，Content-Length 字段不是必需的，因为浏览器发现服务器关闭了 TCP 连接，就表明收到的数据包已经全了

4.  分块传输编码
    使用 Content-Length 字段的前提条件是，服务器发送回应之前，必须知道回应的数据长度。

对于一些很耗时的动态操作来说，这意味着，服务器要等到所有操作完成，才能发送数据，显然这样的效率不高。更好的处理方法是，产生一块数据，就发送一块，采用"流模式"（stream）取代"缓存模式"（buffer）。

因此，1.1 版规定可以不使用 Content-Length 字段，而使用"分块传输编码"（chunked transfer encoding）。只要请求或回应的头信息有 Transfer-Encoding 字段，就表明回应将由数量未定的数据块组成。

```js
// Transfer-Encoding: chunked
```

每个非空的数据块之前，会有一个 16 进制的数值，表示这个块的长度。最后是一个大小为 0 的块，就表示本次回应的数据发送完了

5.  其他功能
    1.1 版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。

另外，客户端请求的头信息新增了 Host 字段，用来指定服务器的域名。
有了 Host 字段，就可以将请求发往同一台服务器上的不同网站，为虚拟主机的兴起打下了基础。

6.  缺点
    虽然 1.1 版允许复用 TCP 连接，但是同一个 TCP 连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为"队头堵塞"（Head-of-line blocking）。

为了避免这个问题，只有两种方法：一是减少请求数，二是同时多开持久连接。这导致了很多的网页优化技巧，比如合并脚本和样式表、将图片嵌入 CSS 代码、域名分片（domain sharding）等等。如果 HTTP 协议设计得更好一些，这些额外的工作是可以避免的。

## SPDY 协议

2009 年，谷歌公开了自行研发的 SPDY 协议，主要解决 HTTP/1.1 效率不高的问题。

这个协议在 Chrome 浏览器上证明可行以后，就被当作 HTTP/2 的基础，主要特性都在 HTTP/2 之中得到继承。

## HTTP/2

2015 年，HTTP/2 发布。它不叫 HTTP/2.0，是因为标准委员会不打算再发布子版本了，下一个新版本将是 HTTP/3。

1.  二进制协议
    HTTP/1.1 版的头信息肯定是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP/2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。

二进制协议的一个好处是，可以定义额外的帧。HTTP/2 定义了近十种帧，为将来的高级应用打好了基础。如果使用文本实现这种功能，解析数据将会变得非常麻烦，二进制解析则方便得多。

2.  多工

HTTP/2 复用 TCP 连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，而且不用按照顺序一一对应，这样就避免了"队头堵塞"。

举例来说，在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分， 接着回应 B 请求，完成后，再发送 A 请求剩下的部分。

这样双向的、实时的通信，就叫做多工（Multiplexing）。

3.  数据流

因为 HTTP/2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。

HTTP/2 将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流 ID，用来区分它属于哪个数据流。另外还规定，客户端发出的数据流，ID 一律为奇数，服务器发出的，ID 为偶数。

数据流发送到一半的时候，客户端和服务器都可以发送信号（RST_STREAM 帧），取消这个数据流。1.1 版取消数据流的唯一方法，就是关闭 TCP 连接。这就是说，HTTP/2 可以取消某一次请求，同时保证 TCP 连接还打开着，可以被其他请求使用。

客户端还可以指定数据流的优先级。优先级越高，服务器就会越早回应。

4.  头信息压缩

HTTP 协议不带有状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。

HTTP/2 对这一点做了优化，引入了头信息压缩机制（header compression）。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。

5.  服务器推送

HTTP/2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送（server push）。

常见场景是客户端请求一个网页，这个网页里面包含很多静态资源。正常情况下，客户端必须收到网页后，解析 HTML 源码，发现有静态资源，再发出静态资源请求。其实，服务器可以预期到客户端请求网页后，很可能会再请求静态资源，所以就主动把这些静态资源随着网页一起发给客户端了。

## HTTPS

## ssl 延迟

客户端首先发送 SYN 数据包，然后服务器发送 SYN+ACK 数据包，最后客户端发送 ACK 数据包，接下来就可以发送内容了。这三个数据包的发送过程，叫做 TCP 握手。

再来看 HTTPs 链接，它也采用 TCP 协议发送数据，所以它也需要上面的这三步握手过程。而且，在这三步结束以后，它还有一个 SSL 握手。

HTTP 耗时 = TCP 握手

HTTPs 耗时 = TCP 握手 + SSL 握手

命令行工具 curl 有一个 w 参数，可以用来测量 TCP 握手和 SSL 握手的具体耗时，以访问支付宝为例。

```js
// $ curl -w "TCP handshake: %{time_connect}, SSL handshake: %{time_appconnect}\n" -so /dev/null https://www.alipay.com

// TCP handshake: 0.022, SSL handshake: 0.064
```

从运行结果可以看到，SSL 握手的耗时（64 毫秒）大概是 TCP 握手（22 毫秒）的三倍。也就是说，在建立连接的阶段，HTTPs 链接比 HTTP 链接要长 3 倍的时间，具体数字取决于 CPU 的快慢和网络状况。

## SSL/TLS 协议运行机制的概述

1.  作用

- 不使用 SSL/TLS 的 HTTP 通信，就是不加密的通信。所有信息明文传播，带来了三大风险。

（1） 窃听风险（eavesdropping）：第三方可以获知通信内容。

（2） 篡改风险（tampering）：第三方可以修改通信内容。

（3） 冒充风险（pretending）：第三方可以冒充他人身份参与通信。

- 希望达到

（1） 所有信息都是加密传播，第三方无法窃听。

（2） 具有校验机制，一旦被篡改，通信双方会立刻发现。

（3） 配备身份证书，防止身份被冒充。

2.  历史
    1994 年，NetScape 公司设计了 SSL 协议（Secure Sockets Layer）的 1.0 版，但是未发布。

1995 年，NetScape 公司发布 SSL 2.0 版，很快发现有严重漏洞。

1996 年，SSL 3.0 版问世，得到大规模应用。

1999 年，互联网标准化组织 ISOC 接替 NetScape 公司，发布了 SSL 的升级版 TLS 1.0 版。

2006 年和 2008 年，TLS 进行了两次升级，分别为 TLS 1.1 版和 TLS 1.2 版。最新的变动是 2011 年 TLS 1.2 的修订版。

目前，应用最广泛的是 TLS 1.0，接下来是 SSL 3.0。但是，主流浏览器都已经实现了 TLS 1.2 的支持。

TLS 1.0 通常被标示为 SSL 3.1，TLS 1.1 为 SSL 3.2，TLS 1.2 为 SSL 3.3。

SSL 是一个独立的协议，不只有 HTTP 可以使用，其他应用层协议也可以使用，比如 SMTP(电子邮件协议)、Telnet(远程登录协议) 等都可以使用。

3.  SSL 协议的握手过程

第一步，客户端给出协议版本号、一个客户端生成的随机数（Client random），以及客户端支持的加密方法。

第二步，服务端确认双方使用的加密方法，并给出数字证书、以及一个服务器生成的随机数（Server random）。

第三步，客户端验证 CA 数字证书是否合法，然后生成一个新的随机数（Premaster secret），并使用数字证书中的公钥，加密这个随机数，发给服务端。

第四步，服务端使用自己的私钥解密客户端发来的随机数（即 Premaster secret）。

第五步，客户端和服务端根据约定的加密方法，使用前面的三个随机数，生成"对话密钥"（session key），用来加密接下来的整个对话过程。(对称加密)

4. 私钥的作用

握手阶段有三点需要注意。

（1）生成对话密钥一共需要三个随机数。

（2）握手之后的对话使用"对话密钥"加密（对称加密），服务器的公钥和私钥只用于加密和解密"对话密钥"（非对称加密），无其他作用。

（3）服务器公钥放在服务器的数字证书之中。

5.  DH 算法的握手阶段

整个握手阶段都不加密（也没法加密），都是明文的。因此，如果有人窃听通信，他可以知道双方选择的加密方法，以及三个随机数中的两个。整个通话的安全，只取决于第三个随机数（Premaster secret）能不能被破解。

虽然理论上，只要服务器的公钥足够长（比如 2048 位），那么 Premaster secret 可以保证不被破解。但是为了足够安全，我们可以考虑把握手阶段的算法从默认的 RSA 算法，改为 Diffie-Hellman 算法（简称 DH 算法）。

采用 DH 算法后，Premaster secret 不需要传递，双方只要交换各自的参数，就可以算出这个随机数。

第三步和第四步由传递 Premaster secret 变成了传递 DH 算法所需的参数，然后双方各自算出 Premaster secret。这样就提高了安全性。

6.  为什么数据传输过程采用的是不是很安全的对称加密

- 非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的
- 另外，在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，

7.  为什么需要 CA 认证机构颁发证书

我们假设不存在认证机构，任何人都可以制作证书，这带来的安全风险便是经典的“中间人攻击”问题，中间人攻击过程：

1.  本地请求被劫持（如 DNS 劫持等），所有请求均发送到中间人的服务器
2.  中间人服务器返回中间人自己的证书
3.  客户端创建随机数，通过中间人证书的公钥对随机数加密后传送给中间人，然后凭随机数构造对称加密对传输内容进行加密传输
4.  中间人因为拥有客户端的随机数，可以通过对称加密算法进行内容解密
5.  中间人以客户端的请求内容再向正规网站发起请求因为中间人与服务器的通信过程是合法的
6.  正规网站通过建立的安全通道返回加密后的数据
7.  中间人凭借与正规网站建立的对称加密算法对内容进行解密
8.  中间人通过与客户端建立的对称加密算法对正规内容返回的数据进行加密传输
9.  客户端通过与中间人建立的对称加密算法对返回结果数据进行解密

10. 证书包含什么

- 公钥
- 公司信息
- 颁发机构
- 域名分片
- 有效期

9.  用了 HTTPS 会被抓包吗

- HTTPS 的数据是加密的，常规下抓包工具代理请求后抓到的包内容是加密状态，无法直接查看。
- 浏览器只会提示安全风险，如果用户授权仍然可以继续访问网站，完成请求。因此，只要客户端是我们自己的终端，我们授权的情况下，便可以组建中间人网络，而抓包工具便是作为中间人的代理。通常 HTTPS 抓包工具的使用方法是会生成一个证书，用户需要手动把证书安装到客户端中，然后终端发起的所有请求通过该证书完成与抓包工具的交互，然后抓包工具再转发请求到服务器，最后把服务器返回的结果在控制台输出后再返回给终端，从而完成整个请求的闭环。
- 既然 HTTPS 不能防抓包，那 HTTPS 有什么意义？HTTPS 可以防止用户在不知情的情况下通信链路被监听，对于主动授信的抓包操作是不提供防护的，因为这个场景用户是已经对风险知情。要防止被抓包，需要采用应用级的安全防护，例如采用私有的对称加密，同时做好移动端的防反编译加固，防止本地算法被破解。

10. 对称加密

- 加密和解密时使用的密钥都是同样的密钥。只要保证了密钥的安全性，那么整个通信过程也就是具有了机密性。

11. 非对称加密

- 非对称加密又称为公钥加密，通过私钥加密后只能用公钥解密，同样通过公钥加密后只能用私钥解密

## 应用层

提供应用程序之间的通信服务，为用户提供直接使用的网络服务

- HTTP (HyperText Transfer Protocol)：用于浏览器和 Web 服务器之间的通信，传输网页数据。
- FTP (File Transfer Protocol)：用于文件上传和下载。
- SMTP (Simple Mail Transfer Protocol)：用于电子邮件发送。
- DNS (Domain Name System)：将域名转换为 IP 地址。

## 传输层

负责端与端的传输

- TCP (Transmission Control Protocol)：面向连接的传输协议，提供可靠的数据传输，具有数据包重传、流量控制、拥塞控制等功能。适用于需要数据完整性的应用，如 HTTP、FTP。
- UDP (User Datagram Protocol)：面向无连接的传输协议，数据传输速度快，但不保证可靠性。适用于对实时性要求高但不需要可靠传输的场景，如视频流、在线游戏

## 网络层

处理数据包的寻址和路由，确保数据能够从源地址传送到目标地址。

- IP (Internet Protocol)：定义了数据包的结构，提供数据包的路由和转发。
  IPv4：使用 32 位地址，广泛使用但地址空间有限。
  IPv6：使用 128 位地址，提供更大的地址空间

- ICMP (Internet Control Message Protocol)：用于网络诊断，比如 ping 命令会使用 ICMP 协议来检测目标主机是否可达。

- ARP (Address Resolution Protocol)：将 IP 地址转换为 MAC 地址（用于局域网通信）。
- RARP (Reverse ARP)：将 MAC 地址转换为 IP 地址。

## 链路层

负责数据在局域网（或物理链路）中的传输。

- Ethernet (以太网)：用于有线局域网数据传输，定义了物理层和数据链路层的协议。
- PPP (Point-to-Point Protocol)：用于直接连接的点对点网络，如拨号连接。
- Wi-Fi (无线网络协议)：用于无线局域网数据传输，基于 IEEE 802.11 标准。
