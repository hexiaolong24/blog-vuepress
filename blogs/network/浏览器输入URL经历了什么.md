---
title: 浏览器输入url经历了什么
date: 2020-09-12
sidebar: 'auto'
categories:
 - network
tags:
 - network
---

#  首先用户输入（两种类型）
当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的URL。
##  关键字
-   如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的URL。
##  符合url规则
-   如果判断输入内容符合URL规则，比如输入的是 time.kbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的URL，如 https://time.kbang.org。

##  图标是加载状态，但页面还有原来的页面
标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为极客时间的页面。因为需要等待提交文档阶段，页面内容才会被替换。

##  URL请求，进程通信IPC将url请求发送至网络进程
首先会查看浏览器是否有缓存该资源（强缓存不会进行tcp链接，结合协商缓存）

##  如果没有缓存，开始网络请求，DNS解析
1.  在发起http请求之前，浏览器首先要做去获得我们想访问网页的IP地址
2.  DNS缓存     
    -   找浏览器DNS缓存解析域名
    -   找本机DNS缓存：ipconfig/displaydns > C:/dns.txt
    -   找路由器DNS缓存
    -   找运营商DNS缓存（百分之80的DNS查找，到这一步就结束）
    -   递归查询，（最不愿意看到的事，查询的是全球13台DNS根服务器中的一个）
3.  DNS负载均衡，返回合适的服务器ip

##  TCP连接 （SSL/TLS链接）
-   TCP/IP协议不仅仅指的是TCP和IP两个协议，⽽是指的⼀个由FTP,SMTP,TCP,UDP,IP,ARP等等协议构成的协议集合。
1.  第一次握手：主机A发送位码为SYN＝1，随机产生Seq=1234567的数据包到服务器，主机B由SYN=1知道，A要求建立联机；（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
2.  第二次握手：主机B收到请求后要确认联机信息，向A发送ack=(主机A的seq+1)，SYN=1，随机产生Seq=7654321的包；（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）
3.  第三次握手：主机A收到后检查ack是否正确，即第一次自己发送的seq+1，以及位码SYN是否为1，若正确，主机A会再发送ack=(主机B的seq+1)，主机B收到后确认ACK=7654321+ 1的值和自己上一次发送的seq的值+1相同，则连接建立成功；（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）
### 为什么三次
-   第一次握手可以确认客服端的发送能力,第二次握手，服务端SYN=1,Seq=Y就确认了发送能力,ACK=X+1就确认了接收能力,所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。

##  如果有重定向，直接从新走一遍请求
-   如果服务器响应行的状态码包含了301、302一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是200，那么表示浏览器可以继续处理该请求。
-   301重定向，被请求的旧资源永久移除了（不可以访问了），将会跳转到一个新资源，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址；
-   302重定向，被请求的旧资源还在（仍然可以访问），但会临时跳转到一个新资源，搜索引擎会抓取新的内容而保存旧的网址。

##  响应数据类型content-type(MIME媒体类型)
-   然后浏览器会根据Content-Type的值来决定如何显示响应体的内容
-   text/html交给渲染进程text/css text/js
-   text/plain未知文本类型
-   默认类型application/octet-stream。出于一些安全原因，对于这些资源浏览器不允许设置一些自定义默认操作，交给下载管理器处理导致用户必须存储到本地以使用。

### MIME 嗅探
-   在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行MIME嗅探。
##  准备好渲染进程还不能进入文档解析状态，还没有提交文档
-   通常情况下，打开新的页面都会使用单独的渲染进程；
-   如果从A页面打开B页面，且A和B都属于同一站点的话，那么B页面复用A页面的渲染进程；如果是其他情况，浏览器进程则会为B创建一个新的渲染进程。

##  提交文档
-   浏览器主进程发出信号，渲染进程和网络进程建立通道
-   响应数据接收完后，渲染进程会向浏览器进程发送信号
-   浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的URL、前进后退的历史状态，并更新Web页面。
-   这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

##  渲染阶段，html，js，css如何变成页面

-   html超文本标记语言
-   css重叠样式表
-   js操作dom

### 构建DOM树、样式计算、布局阶段（重排）、分层、图层绘制（重绘）、合成。

###  构建DOM树 控制台输入document
为什么要构建DOM树呢？这是因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结构——DOM树
###  样式计算（样式表）控制台输入document.styleSheets
样式计算的目的是为了计算出DOM节点中每个元素的具体样式，这个阶段大体可分为三步来完成
-   来源：link styleb标签 内联样式
1.  和HTML文件一样，浏览器也是无法直接理解这些纯文本的CSS样式，所以当渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构——styleSheets
2.  转换样式表中的属性值，使其标准化
3.  计算出DOM树中每个节点的具体样式

### 布局阶段 layout (重排)
-   布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。
1.  创建布局树
2.  布局计算
-   尽量减少布局
-   使用flex布局
-   避免强制同步布局，操作样式之后立马读取样式
-   避免布局抖动
### 分层（图层） LayerTree
1.   第一点，拥有层叠上下文属性的元素会被提升为单独的一层。
```css
position: fixed;
z-index: 10;
filer: blue(5px); // 过滤
opacity: 0.5;
```
2.   第二点，需要剪裁（clip）的地方也会被创建为图层。overflow:auto;

-   Chrome浏览器满足以下任意情况就会创建图层：
	1. 拥有具有3D变换的CSS属性
	2. 使用加速视频解码的 video 节点
	3. canvas 节点
	4. CSS3动画的节点
	5. 拥有CSS加速属性的元素(will-change)

### 图层绘制 Paint
-   绘制是填充像素的过程，像素最终合成到用户的屏幕上。 它往往是管道中运行时间最长的任务，应尽可能避免此任务
-   除 transform 或 opacity 属性之外，更改任何属性始终都会触发绘制
-   通过层的提升和动画的编排来减少绘制区域
-   创建新层的最佳方式是使用 will-change CSS 属性。此方法在 Chrome、Opera 和 Firefox 上有效，并且通过 transform 的值将创建一个新的合成器层:
```js
.moving-element {
  will-change: transform;
}
```
-   对于不支持 will-change 但受益于层创建的浏览器，例如 Safari 和 Mobile Safari，需要使用 3D 变形来强制创建一个新层:
-   但需要注意的是: 不要创建太多层，因为每层都需要内存和管理开销
### Composite 直接图层合成，之前又加了一个分块栅格化
-   transform opacity 只有这两个属性会直接进入合成阶段
-   opacity透明度的改变时，GPU在绘画时只是简单的降低之前已经画好的纹理的alpha值来达到效果，并不需要整体的重绘。


#   DOM树如何生成
-   HTML 解析器：是网络进程加载了多少数据，HTML 解析器便解析多少数据。
-   HTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中
-   过程：
    1.  通过分词器将字节流转换为 Token
    2.  至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。

#  遇到js文件阻塞dom
-   原因： JavaScript 有可能会修改当前状态下的 DOM。
-   预解析操作：开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。
-   async defer,defer会在DOMContentLoaded之前执行，async会阻止onload
-   defer - DOMContentLoaded  - async - onload
```js
<script async type="text/javascript" src='foo.js'></script>
```

#  css阻塞js
-   原因：页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。

#   整体流程
-   在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。

-   后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。

### 空闲时间
-   请求 HTML 数据和构建 DOM 中间有一段空闲时间
-   DOM 构建结束之后，但是css 文件还未下载完成的这段时间内，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。






