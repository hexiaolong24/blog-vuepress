---
title: 浏览器输入url经历了什么
date: 2020-09-12
sidebar: "auto"
categories:
  - network
tags:
  - network
---

# 首先用户输入（两种类型）

当用户在地址栏中输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容，还是请求的 URL。

## 关键字

- 如果是搜索内容，地址栏会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。

## 符合 url 规则

- 如果判断输入内容符合 URL 规则，比如输入的是 time.kbang.org，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL，如 https://time.kbang.org。

## 图标是加载状态，但页面还有原来的页面

标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为新页面。因为需要等待提交文档阶段，页面内容才会被替换。

## URL 请求，进程通信 IPC 将 url 请求发送至网络进程

首先会查看浏览器是否有缓存该资源（强缓存不会进行 tcp 链接，结合协商缓存）

## 如果没有缓存，开始网络请求，DNS 解析

1.  在发起 http 请求之前，浏览器首先要做去获得我们想访问网页的 IP 地址
2.  DNS 缓存
    - 找浏览器 DNS 缓存解析域名
    - 找本机 DNS 缓存：ipconfig/displaydns > C:/dns.txt
    - 找路由器 DNS 缓存
    - 找运营商 DNS 缓存（百分之 80 的 DNS 查找，到这一步就结束）
    - 递归查询，（最不愿意看到的事，查询的是全球 13 台 DNS 根服务器中的一个）
3.  DNS 负载均衡，返回合适的服务器 ip

## TCP 连接 （SSL/TLS 链接）

- TCP/IP 协议不仅仅指的是 TCP 和 IP 两个协议，⽽是指的⼀个由 FTP,SMTP,TCP,UDP,IP,ARP 等等协议构成的协议集合。

1.  第一次握手：主机 A 发送位码为 SYN ＝ 1，随机产生 Seq=1234567 的数据包到服务器，此时主机A进入SYN-SEND状态，主机 B 由 SYN=1 知道，A 要求建立联机；（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
2.  第二次握手：主机 B 收到请求后要确认联机信息，向 A 发送 ack=(主机 A 的 seq+1)，SYN=1，随机产生 Seq=7654321 的包；（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧），此时主机B进入SYN-RECEIVED状态
3.  第三次握手：主机 A 收到后检查 ack 是否正确，即第一次自己发送的 seq+1，以及位码 SYN 是否为 1，若正确，主机 A 会再发送 ack=(主机 B 的 seq+1)，此时主机A已经进入established状态（已确认）主机 B 收到后确认 ACK=7654321+ 1 的值和自己上一次发送的 seq 的值+1 相同，则连接建立成功；（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）

### 为什么三次

- 第一次握手可以确认客服端的发送能力,第二次握手，服务端 SYN=1,Seq=Y 就确认了发送能力,ACK=X+1 就确认了接收能力,所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。

## 如果有重定向，直接从新走一遍请求

- 如果服务器响应行的状态码包含了 301、302 一类的跳转信息，浏览器会跳转到新的地址继续导航；如果响应行是 200，那么表示浏览器可以继续处理该请求。
- 301 重定向，被请求的旧资源永久移除了（不可以访问了），将会跳转到一个新资源，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址；
- 302 重定向，被请求的旧资源还在（仍然可以访问），但会临时跳转到一个新资源，搜索引擎会抓取新的内容而保存旧的网址。

## 响应数据类型 content-type(MIME 媒体类型)

- 然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容
- text/html 交给渲染进程 text/css text/js
- text/plain 未知文本类型
- 默认类型 application/octet-stream。出于一些安全原因，对于这些资源浏览器不允许设置一些自定义默认操作，交给下载管理器处理导致用户必须存储到本地以使用。

### MIME 嗅探

- 在缺失 MIME 类型或客户端认为文件设置了错误的 MIME 类型时，浏览器可能会通过查看资源来进行 MIME 嗅探。

## 准备好渲染进程还不能进入文档解析状态，还没有提交文档

- 通常情况下，打开新的页面都会使用单独的渲染进程；
- 如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。

## 提交文档

- 浏览器主进程发出信号，渲染进程和网络进程建立通道
- 响应数据接收完后，渲染进程会向浏览器进程发送信号
- 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。
- 这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。

## 渲染阶段，html，js，css 如何变成页面

- html 超文本标记语言
- css 重叠样式表
- js 操作 dom

### 构建 DOM 树、样式计算、布局阶段（重排）、分层、图层绘制（重绘）、合成。

### 构建 DOM 树 控制台输入 document

为什么要构建 DOM 树呢？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树

### 样式计算（样式表）控制台输入 document.styleSheets

样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成

- 来源：link style 标签 内联样式

1.  和 HTML 文件一样，浏览器也是无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets
2.  转换样式表中的属性值，使其标准化
3.  计算出 DOM 树中每个节点的具体样式

### 布局阶段 layout (重排)

- 布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。

1.  创建布局树
2.  布局计算

- 尽量减少布局
- 使用 flex 布局
- 避免强制同步布局（操作样式之后立马读取样式）
- 避免布局抖动

### 分层（图层） LayerTree

1.  第一点，拥有层叠上下文属性的元素会被提升为单独的一层。

```css
position: fixed;
z-index: 10;
filer: blue(5px); // 过滤
opacity: 0.5;
```

2.  第二点，需要剪裁（clip）的地方也会被创建为图层。overflow:auto;

- Chrome 浏览器满足以下任意情况就会创建图层：
  1.  拥有具有 3D 变换的 CSS 属性
  2.  使用加速视频解码的 video 节点
  3.  canvas 节点
  4.  CSS3 动画的节点
  5.  拥有 CSS 加速属性的元素(will-change)

### 图层绘制 Paint

- 绘制是填充像素的过程，像素最终合成到用户的屏幕上。 它往往是管道中运行时间最长的任务，应尽可能避免此任务
- 除 transform 或 opacity 属性之外，更改任何属性始终都会触发绘制
- 通过层的提升和动画的编排来减少绘制区域
- 创建新层的最佳方式是使用 will-change CSS 属性。此方法在 Chrome、Opera 和 Firefox 上有效，并且通过 transform 的值将创建一个新的合成器层:

```js
.moving-element {
  will-change: transform;
}
```

- 对于不支持 will-change 但受益于层创建的浏览器，例如 Safari 和 Mobile Safari，需要使用 3D 变形来强制创建一个新层:
- 但需要注意的是: 不要创建太多层，因为每层都需要内存和管理开销

### Composite 直接图层合成，之前又加了一个分块栅格化

- transform opacity 只有这两个属性会直接进入合成阶段
- opacity 透明度的改变时，GPU 在绘画时只是简单的降低之前已经画好的纹理的 alpha 值来达到效果，并不需要整体的重绘。

# DOM 树如何生成

- HTML 解析器：是网络进程加载了多少数据，HTML 解析器便解析多少数据。
- HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中
- 过程：
  1.  通过分词器将字节流转换为 Token
  2.  至于后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。

# DOM 树的作用

- 从页面的视角来看，DOM 是生成页面的基础数据结构
- 从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容
- 从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了

# 遇到 js 文件阻塞 dom

- 原因： JavaScript 有可能会修改当前状态下的 DOM。
- 预解析操作：开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。
- 不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码
- async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行,async 会阻止 onload
- defer - DOMContentLoaded - async - onload

```js
<script async type="text/javascript" src="foo.js"></script>
```

# css 阻塞 js

- 原因：页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。

# CSSOM 的两个作用

- 第一个是提供给 JavaScript 操作样式表的能力
- 第二个是为布局树的合成提供基础的样式信息。这个 CSSOM 体现在 DOM 中就是 document.styleSheets。

# 整体流程

- 在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。

- 后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。

### 空闲时间

- 请求 HTML 数据和构建 DOM 中间有一段空闲时间
- DOM 构建结束之后，但是 css 文件还未下载完成的这段时间内，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。
