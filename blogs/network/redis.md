---
title: redis
date: 2021-08-02
sidebar: 'auto'
categories:
 - network
tags:
 - redis
---

##  NoSQL
- not only sql 非关系型数据库
- 不依赖业务逻辑方式存储，key-value形式存储，增加了数据库的扩展能力
- 解决io性能，存储在缓存中
- 解决CPU、内存压力，存在内存中，不进行io读写
- 不遵循sql标准
- 支持事务，但是不支持ACID(原子性、一致性、隔离性、持久性)
- 远超sql性能

##  场景
- 数据高并发读写
- 海量数据读写
- 数据高扩展性

##  Redis是单线程的吗

不是，我们知道Redis是一个Key-Value的非关系型数据库，我们所理解的Redis单线程主要是指网络IO和K-V的读写是由一个主线程来完成的。但Redis的其他功能，比如说持久化、异步删除、集群数据同步，其实是开启了额外的线程来完成的。

##  Redis单线程为什么还能这么快

因为Redis是基于内存的，所有的运算都是内存级别的，而且单线程避免了多线程的切换性能耗损问题。

##  Redis单线程如何处理那么多并发客户端连接

这里就要扯到NIO多路复用模型

##  Redis支持的5种数据结构

String、Hash、List、Set、ZSet

##  Redis持久化

Redis最大的特点就是基于内存的，既然是基于内存，那么当Redis服务挂掉或者服务器宕机，数据则会丢失，所以Redis不可避免的得对数据持久化做一些处理，像MySQL,MQ数据就保留在磁盘上，那Redis同理，Redis有3种持久化方式： RDB、AOF、混合持久化。

### RDB
- fork一个子进程，在内存中保存一份快照（写时拷贝），可以理解为react中的双缓存技术，之后替换掉dump.rdb
在默认情况下， Redis 将内存数据库快照保存在名字为 dump.rdb 的二进制文件中。
你可以对 Redis 进行设置， 让它在“ N 秒内数据集至少有 M 个改动”这一条件被满足时，自动保存一次数据集。
比如说， 设置`save 60 1000`会让 Redis 在满足“ 60 秒内有至少有 1000 个键被改动”这一条件时， 自动保存一次数据集。
关闭RDB只需要将所有的save保存策略注释掉即可

还可以手动执行命令生成RDB快照，客户端执行命令save或bgsave可以生成dump.rdb文件，
每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。

save是同步命令，bgsave是异步命令，bgsave会从Redis主进程fork（fork()是linux函数）出一个子进程专门用来生成rdb快照文件

Redis默认是使用的bgsave
- 优势
  - 适合大规模数据恢复
  - 对数据完整性和一致性要求不高
  - 节省磁盘空间
  - 恢复速度快
- 劣势
  - fork时内存中数据被克隆了一份，2倍的膨胀率需要考虑
  - 使用了写时拷贝技术，但是性能消耗比较大
  - 丢失最后一次快照的数据

### AOF
AOF 持久化: 将修改的每一条指令记录进文件appendonly.aof中
- 默认不开启
- 同时开启，默认取aof
- 修改配置文件来打开 AOF 功能：`appendonly yes`

### 流程
  - 每当 Redis 执行一个改变数据集的命令时（比如 SET)， 这个命令就会被追加到 AOF 缓冲区
  - AOF缓冲区根据同步频率策略将操作sync同步到磁盘的aof文件中
  - 当 Redis 重新启动时， 程序就可以通过重新执行 AOF 文件中的命令来达到重建数据集的目的。

- aof同步频率设置
1. appendfsync always：每次有新命令追加到 AOF 文件时就执行一次 fsync ，非常慢，也非常安全。
2. appendfsync everysec：每秒 fsync 一次，足够快（和使用 RDB 持久化差不多），并且在故障时只会丢失 1 秒钟的数据。
3. appendfsync no：从不 fsync ，将数据交给操作系统来处理。更快，也更不安全的选择。

推荐（并且也是默认）的措施为每秒 fsync 一次， 这种 fsync 策略可以兼顾速度和安全性。
- aof文件 reweite 重写压缩操作
  - 将多条命令合并成一条，不关心中间过程，只关心结果
  - 当aof文件大于64M的100%（也就是128M）才触发

###  混合持久化（加强版的AOF）

重启 Redis 时，我们很少使用 RDB来恢复数据，因为会丢失大量数据。
我们通常使用 AOF 日志重放，但是重放 AOF 日志性能相对 RDB来说要慢很多，这样在 Redis 实例很大的情况下，启动需要花费很长的时间。 
Redis 为了解决这个问题，带来了一个新的持久化方式——混合持久化。

通过如下配置可以开启混合持久化：`aof-use-rdb-preamble yes`

如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，
而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，
新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换。

于是在 Redis 重启的时候，可以先加载 RDB 的内容，然后再重放增量 AOF 日志就可以完全替代之前的 AOF 全量文件重放，
因此重启效率大幅得到提升。

