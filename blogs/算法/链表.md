---
title: 链表
date: 2020-08-09
sidebar: 'auto'
categories:
 - 算法
tags:
 - 算法
---

##  203.移除链表元素
```js
var removeElements = function(head, val) {
    // 返回一个节点
    const ret = new ListNode(0, head)
    // 当前节点为头节点
    let cur = ret
    while(cur.next) {
        if(cur.next.val === val) {
            // 这一步跳过的是等于目标的节点，可以影响ret
            cur.next = cur.next.next
        }else {
            // 这里只是改变当前节点，与ret无关
            cur = cur.next
        }
    }
    return ret.next
};
```

##  206.反转链表
```js
var reverseList = function(head) {
    if(!head || !head.next) {
        return head
    }
    let temp = pre = null,cur = head
    // 1 2 3
    while(cur) {
        temp = cur.next
        cur.next = pre
        pre = cur
        cur = temp
    }
    return pre
};
```

##  92 反转部分链表
1.  定义两个指针，分别称之为 g(guard 守卫) 和 p(point)。首先根据方法的参数 left 确定 g 和 p 的位置。将 g 移动到第一个要反转的节点的前面，将 p 移动到第一个要反转的节点的位置上。以 left=2，right=4为例。
2.  将 p 后面的元素删除，然后添加到 g 的后面。也即头插法。
3.  根据 left 和 right 重复步骤（2）
4.  返回 vhead.next
```js
var reverseBetween = function(head, left, right) {
    let vhead = new ListNode(0, head)
    let g = vhead,p = vhead.next
    for(let i = 0; i < left - 1; i++) {
        g = g.next 
        p = p.next
    }
    for(let i = 0; i< right - left; i++) {
        let removed = p.next
        p.next = p.next.next
        // g的位置不变
        removed.next = g.next
        g.next = removed
    }
    return vhead.next
};
```

##  2 两数相加
```js
var addTwoNumbers = function(l1, l2) {
    let addVal = 0, // 进位
        vHead = new ListNode(0), // 虚拟头节点，保存返回的节点
        sum = vHead;
    while(addVal || l1 || l2) {
        let val1 = l1 ? l1.val : 0, // 如果为null 置为0
            val2 = l2 ? l2.val : 0,
            r1 = val1 + val2 + addVal; // 两数相加 + 进位
        addVal = r1 >= 10 ? 1 : 0; // 计算进位的值
        sum.next = new ListNode(r1 % 10); 
        sum = sum.next;
        if(l1) l1 = l1.next;
        if(l2) l2 = l2.next;
    }
    return vHead.next
};
```

##  21 合并两个有序链表
```js
var mergeTwoLists = function(list1, list2) {
    if(!list1) return list2
    if(!list2) return list1
    if(list1.val < list2.val) {
        list1.next = mergeTwoLists(list1.next, list2)
        return list1
    }else {
        list2.next = mergeTwoLists(list2.next, list1)
        return list2
    }
};
```