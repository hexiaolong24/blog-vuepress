---
title: 动态规划
date: 2020-08-09
sidebar: 'auto'
categories:
 - 算法
tags:
 - 算法
 - 动态规划
---

##  动态规划一般形式就是求最值
-   动态规划其实是运筹学的一种最优化方法
-   求解动态规划的核心问题是穷举
-   重叠子问题、最优子结构、状态转移方程就是动态规划三要素

-   状态转移方程 --- 你把 f(n) 想做一个状态 n，这个状态 n 是由状态 n - 1 和状态 n - 2 相加转移而来，这就叫状态转移，仅此而已。

-   明确「状态」 -> 定义 dp 数组/函数的含义 -> 明确「选择」-> 明确 base case。

##  递归算法的时间复杂度 = 子问题个数乘以解决一个子问题需要的时间


##  509 菲波那切数列
-   暴力递归
```js
/**
 * 解法一：暴力递归(自顶向下)
 * 
 * 时间复杂度：O(2^n)，指数级别
 * 空间复杂度：O(n)
 * 
 * 注意点：
 * (1)注意爆栈
 * (2)存在重复的调用计算
 * 
 * @param {*} n 
 */
var fib = function(n) {
    if(n === 0) return 0
    if(n === 1) return 1
    return fib(n-1) + fib(n-2)
};
```


```js
/**
 * 解法二：备忘录递归(自顶向下)
 * 解法一递归的升级版
 * 
 * 比解法一多了个“备忘录”储存，"剪枝"处理技巧，可以去除重复的调用计算
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 * 
 * @param {*} n 
 */
function fib(n) {
    let sumMap = {};
    return myFib(n, sumMap); 
}

function myFib(n, sumMap) {
    if (n === 0) {
        return 0;
    }
    if (n === 1 || n === 2) {
        return 1;
    }
    if (sumMap[n]) {
        return sumMap[n];
    }
    const rst = myFib(n-2, sumMap) + myFib(n-1, sumMap);
    sumMap[n] = rst;
    return rst;
}
```
-   DP 表
```js
/**
 * 解法三：动态规划(自底向上)
 * 
 * 解法二备忘录存储技巧的升级，使用dp数组来单独存储这个备忘录
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 * 
 * @param {*} n 
 */
var fib = function(n) {
    let res = []
    res[0] = 0
    res[1] = 1
    for(let i = 2; i <= n; i++){
        res[i] = res[i -1] + res[i-2]
    }
    return res[n]
};
```
-   bp表优化
```js
/**
 * 解法四：动态规划(自底向上)
 * 
 * 解法三的优化，利用(状态压缩技巧)，其实状态只跟前一个数和当前数有关，
 * 不需要像第三种解法那样用一个数组进行存储，只需用两个值存储即可
 * 
 * 时间复杂度：O(n)
 * 空间复杂度：O(n)
 * 
 * @param {*} n 
 */
function fib(n) {
    if (n === 0) {
        return 0;
    }
    if (n === 1 || n === 2) {
        return 1;
    }
    let pre = 1;
    let cur = 1;
    for (let i = 3; i <= n; i++) {
        const sum = pre + cur;
        pre = cur;
        cur = sum;
    }
    return cur;
}
```

##  53 最大子序和
-   之所以要判断sum是否大于0的原因是，通常思维会考虑，从第一个开始往后加，如果下一个大于0则加上，如果小于0则不加，但是这样会有一个问题就是当大于0需要加的时候，此时sum可能是负数，那么结果就错了，加一个正数的提前是sum是大于0的，如果不是大于0的，那么直接把当前元素赋值给sum
```js
function fn(nums){
    let sum = 0;
    let max = nums[0];
    for (const item of nums) {
        if(sum > 0) { // sum + item > item
            sum += item
        }else {
            sum = item
        }
        max = Math.max(sum, max)
    }
    return max
}
```
##  3 查找无重复子串
```js
function fn(s) {
    if(s.length === 0) {
        return 0
    }
    let arr = []
    let maxLength = 0
    for(let item of s) {
        let index = arr.indexOf(item)
        if(index === -1) {
            arr.push(item) // 如果没有直接放入数组
        }else {
            // 如果有那么先把前面有的包括它自己都截掉，因为是要子串（连续的），所以必须push新的删除老的
            arr = arr.slice(index + 1) 
            arr.push(item)
        }
        maxLength = Math.max(maxLength, arr.length)
    }
    return maxLength
}
```

##  70 爬楼梯(和裴波那契数列一样)
```js
function fn(n) {
    let res = []
    res[1] = 1
    res[2] = 2
    for(let i = 3; i <= n; i++) {
        res[i] = res[i-2] + res[i-1]
    }
    return res[n]
}
``` 

```js
var climbStairs = function(n) {
    if(n === 1) return 1
    if(n === 2) return 2
    let per = 1,
        cur = 2

    for(let i = 3; i <= n; i++) {
        let sum = per + cur
        per = cur
        cur = sum
    }
    return cur
};
```

##  花费最小力气爬楼梯
```js
function fn(cost) {
    let per = cur = 0, i = 1
    // 由于可以选择下标 0 或 1 作为初始阶梯，因此有 per = cur = 0
    while(i++ < cost.length) {
        // for(let i = 2; i < cost.length; i ++)
        // 第一次 i = 2,最后一次进来是 i = n, 因为是n-1进来的，进来之后已经执行++，所以是n
        let sum = Math.min(per + cost[i-2], cur + cost[i-1])
        per = cur
        cur = sum
    }
    return cur
}
```

##  剑指 Offer II 103. 最少的硬币数目
-   给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

```js
// 输入：coins = [1, 2, 5], amount = 11
// 输出：3 
// 解释：11 = 5 + 5 + 1
function coinChange(coins, amount) {
    const memo = new Map()
    // map结构  {目标金额，最少数量}
    memo.set(0, 0)
    //  硬币数组 目标金额
    const coinChangeHelper = (coins, amount, memo) => {
        // 如果map结构中有，直接返回
        if (memo.has(amount)) {
            return memo.get(amount)
        }
        // 设置需要的最小数量先为 Infinity
        let minCount = Infinity
        // coins [1, 2, 5]
        for (let i = 0; i < coins.length; i++) {
            const coin = coins[i]
            // 如果单个硬币面值超过了总金额，则直接跳过
            if (coin > amount) {
                continue
            }
            // res剩余金额
            const res = amount - coin
            // 剩余金额递归
            const resMinCount = coinChangeHelper(coins, res, memo)
            if (resMinCount === -1) {
                continue
            }
            minCount = Math.min(minCount, resMinCount + 1)
        }
        // 如果目标金额无法完成，则返回-1
        if (minCount === Infinity) {
            memo.set(amount, -1)
            return -1
        }
        memo.set(amount, minCount)
        return minCount
    }
    return coinChangeHelper(coins, amount, memo)
};
```


