---
title: 二叉树
date: 2020-08-09
sidebar: 'auto'
categories:
 - 算法
tags:
 - 算法
 - 二叉树
---

##  TIPS
-   二叉树题目的要求细化，搞清楚根节点应该做什么，然后剩下的事情抛给前/中/后序的遍历框架就行了，我们千万不要跳进递归的细节里，你的脑袋才能压几个栈呀。

##  二叉树前序遍历 中左右
root root.left root.right
##  二叉树中序遍历 左中右
root.left root root.right
##  二叉树后序遍历 左右中
root.left root.right root

##  144 二叉树前序遍历

-   递归
```js
/**
 * Definition for a binary tree node.
 * function TreeNode(val, left, right) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.left = (left===undefined ? null : left)
 *     this.right = (right===undefined ? null : right)
 * }
 */
/**
 * @param {TreeNode} root
 * @return {number[]}
 */
var preorderTraversal = function(root) {
    let res = []
    if(root == null) {
        return res
    }
    let order = root => {
        res.push(root.val)
        if(root.left !== null) {
            order(root.left)
        }
        if(root.right !== null) {
            order(root.right)
        }
    }
    order(root)
    return res
};
```

-   迭代（栈）

##  94 二叉树中序遍历
```js
var inorderTraversal = function(root) {
    let res = []
    if(root == null) {
        return res
    }
    let order = root => {
        if(root.left !== null) {
            order(root.left)
        }
        res.push(root.val)
        if(root.right !== null) {
            order(root.right)
        }
    }
    order(root)
    return res
};
```

##  145 后序遍历
```js
var postorderTraversal = function(root) {
    let res = [];
    if(root == null) return res;
    let order = (root) => {
        if(root.left) {
            order(root.left)
        }
        if(root.right) {
            order(root.right)
        }
        res.push(root.val)
    }
    order(root);
    return res;
};
```

##  226 翻转二叉树
```js
var invertTree = function(root) {
    if(root == null) {
        return null
    }
    let tem = root.left
    root.left = root.right
    root.right = tem
    invertTree(root.left)
    invertTree(root.right)
    return root
};
```

##  116 填充每个节点的下一个右侧节点指针
```js
let connect = function(root) {
    if(root == null) {
        return null
    }
    func(root.left, root.right)
    return root
};
let func = function(root1, root2) {
    if(root1 == null || root2 == null) {
        return null
    }
    root1.next = root2
    func(root1.left, root1.right)
    func(root2.left, root2.right)
    func(root1.right, root2.left)
};
```

##  114 二叉树展开为链表
```js
var flatten = function(root) {
    if (root == null) return;

    flatten(root.left);
    flatten(root.right);

    let left = root.left;
    let right = root.right;

    root.left = null;
    root.right = left;

    let p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
};
```

## 654 最大二叉树
```js
var constructMaximumBinaryTree = function(nums) {
    if(nums.length === 0) {
        return null
    }
    let maxVal = nums[0]
    let index = 0
    for (let i = 0; i < nums.length; i++) {
        if(nums[i] > maxVal) {
            maxVal = nums[i]
            index = i
        }
    }
    let root = new TreeNode(maxVal)
    let left = []
    let right = []
    for (let i = 0; i < index; i++) {
        left.push(nums[i])
    }
    for (let i = index + 1; i < nums.length; i++) {
        right.push(nums[i])
    }
    root.left = constructMaximumBinaryTree(left)
    root.right = constructMaximumBinaryTree(right)
    return root
};
```

##  105 前序遍历和中序遍历构造二叉树
-   root root.left root.right
-   root.left root root.right
```js
let buildTree = (preorder, inorder) => {

  //当preorder和inorder均为空的时候说明已经到了空节点
  if (!preorder.length || !inorder.length) return null;

  //创建根节点 -> preorder[0]
  let node = new TreeNode(preorder[0]);

  //找到preoder[0]对应inorder中的位置
  let index = inorder.indexOf(preorder.shift());

  //左右子树递归
  node.left = buildTree(preorder, inorder.slice(0, index));
  node.right = buildTree(preorder, inorder.slice(index + 1));

  //返回根节点
  return node;
};
```

##  106 中序遍历和后序遍历构造二叉树
-   root.left root root.right
-   root.left root.right root
```js
var buildTree = function(inorder, postorder) {
    if(!inorder.length || !postorder.length) return null
    let root = new TreeNode(postorder[postorder.length-1])
    let index = inorder.indexOf(postorder.pop())
    root.left = buildTree(inorder.slice(0, index), postorder.slice(0, index))
    root.right = buildTree(inorder.slice(index + 1), postorder.slice(index))
    return root
};
```

##  652 寻找重复的子树
```js

var findDuplicateSubtrees = function(root) {
    const count = new Map()
    const ans = []

    const collect = (node) => {
        if (!node) {
            return '#'
        }
        const key = node.val + ',' + collect(node.left) + collect(node.right)
        if (count.has(key)) {
            count.set(key, count.get(key) + 1)
        } else {
            count.set(key, 1)
        }
        if (count.get(key) === 2) {
            ans.push(node)
        }
        return key
    }

    collect(root)
    return ans
};
```