---
title: 回溯算法
date: 2020-08-09
sidebar: 'auto'
categories:
 - 算法
tags:
 - 算法
 - 回溯
---

##  46 全排列
```js
function permute(nums) {
    let res = [],
        used = {}
    function dfs(path) {
        if(path.length === nums.length) {
            res.push(path.slice())
            return
        }
        for(let num of nums) {
            // if (path.includes(num)) continue; // 别这么写！查找的时间是O(n)，增加时间复杂度
            if(used[num]) continue
            path.push(num)
            used[num] = true
            dfs(path)
            path.pop()
            used[num] = false
        }
    }
    dfs([])
    return res
}
```

##  698 划分为K个相等的子集
```js
var canPartitionKSubsets = function(nums, k) {
    const total = nums.reduce((total, num) => total + num, 0)
    const target0 = total / k // 目标组合的和
    if (target0 !== Math.floor(target0)) return false
    let used = new Array(nums.length).fill(false)
    nums.sort((a, b) => a - b) // 从小到大排序
    // 如果找到 k - 1 个目标组合，那么剩下的数肯定能组成第 k 个目标组合
    return dfs(target0, k - 1, 0, used, nums)

    // 返回是否找到 k 个目标组合，
    // target 表示当前组合还可以容纳多大的数
    function dfs(target, k, start, used, nums) {
        // 找到一个目标组合，接着找下一个目标组合
        if (target === 0) return dfs(target0, k - 1, 0, used, nums)
        if (k === 0) return true // 已找到所有目标组合
        // 尝试将每个数放入当前组合
        // 因为是找组合，无需回头尝试，比如组合 {a, b} 和组合 {b, a} 是等价的
        for (let i = start; i < nums.length; ++i) {
            if (used[i]) continue
            const num = nums[i]
            // 可行性剪枝: 
            // num 无法构成目标组合
            // nums 从小到大排序，既然 nums[i] 都偏大了， nums[i + 1] 更加偏大，无需尝试
            if (num > target) return false
            used[i] = true
            const got = dfs(target - num, k, i + 1, used, nums) // 找当前组合的下一个数
            if (got) return got
            used[i] = false
        }
        return false
    }
}
```

##  78 子集
```js
const subsets = (nums) => {
    const res = [];
    const dfs = (index, list) => {
        res.push(list.slice()); // 调用子递归前，加入解集
        for (let i = index; i < nums.length; i++) { // 枚举出所有可选的数
            list.push(nums[i]); // 选这个数
            dfs(i + 1, list); // 基于选这个数，继续递归，传入的是i+1，不是index+1
            list.pop(); // 撤销选这个数
        }
    };
    dfs(0, []);
    return res;
};
```