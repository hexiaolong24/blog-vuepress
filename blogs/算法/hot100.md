---
title: hot100
date: 2020-08-09
sidebar: 'auto'
categories:
 - 算法
tags:
 - 算法
---

##  338 比特位计数
```js
var countBits = function(n) {
let res = [0]
  for(let i =1; i<= n; i++) {
    res.push(i.toString(2).match(/1/g).length)
  }
  return res
};
```

##  461 汉明距离
```js
var hammingDistance = function(x, y) {
  let strX = x.toString(2)
  let strY = y.toString(2)
  let maxLength = Math.max(strX.length, strY.length)
  strX = strX.padStart(maxLength, 0)
  strY = strY.padStart(maxLength, 0)
  let count = 0
  for(let i = 0; i< maxLength; i++) {
    if(strX[i] !== strY[i]) count++
  }
  return count
};
```

##  消消乐
```js
let boards = [
        [ 'a', 'a', 'a', 'a' ],
        [ 'b', 'c', 'd', 'a' ],
        [ 'b', 'd', 'a', 'b' ],
        [ 'b', 'a', 'b', 'c' ],
      ]
// 输出
//   [
//     [ [ 0, 0 ], [ 0, 1 ], [ 0, 2 ], [ 0, 3 ] ], // 横向4个a的坐标
//     [ [ 1, 0 ], [ 2, 0 ], [ 3, 0 ] ], // 纵向3个b
//   ]
function fn(boards) {
  let res = []
  for(let i = 0; i< boards.length; i++) {
    let curArrheng = [[i, 0]]
    let temheng = boards[i][0]
    let curArrshu = [[0, i]]
    let temshu = boards[0][i]
    for(let j = 1; j< boards[0].length; j++) {
      if(boards[i][j] === temheng) {
        curArrheng.push([i, j])
      }else {
        if(j === 1) {
          curArrheng = []
          curArrheng.push([i, j])
          temheng = boards[i][1]
        }else {
          curArrheng = []
        }
      }

      if(boards[j][i] === temshu) {
        curArrshu.push([j, i])
      }else {
        if(j === 1) {
          curArrshu = []
          curArrshu.push([j, i])
          temshu = boards[1][i]
        }else {
          curArrheng = []
        }
      }
    }
    if(curArrheng.length >= 3) {
      res.push([...curArrheng])
    }
    if(curArrshu.length >= 3) {
      res.push([...curArrshu])
    }
  }
  return res
}
console.log(fn(boards))
```

##  128 最长连续序列
```js
var longestConsecutive = function(nums) {
  let set = new Set(nums)
  let res = 0
  for(let item of set) {
    if(!set.has(item - 1)) {
      let cur = item
      let count = 1
      while(set.has(cur + 1)) {
        cur++
        count++
      }
      res = Math.max(res, count)
    }
  }
  return res
};
```

#  动态规划
- ##  322 零钱兑换
-   求凑成金额所需最少的硬币数
-   完全背包
```js
var coinChange = function(coins, amount) {
    if(!amount) return 0
    let dp = new Array(amount + 1).fill(Infinity)
    dp[0] = 0
    for(let i = 0; i< coins.length; i++) {
        for(let j = coins[i]; j<= amount; j++) {
            dp[j] = Math.min(dp[j], dp[j-coins[i]] + 1)
        } 
    }
    return dp[amount] === Infinity ? -1 : dp[amount]
};
```

##  300.最长递增子序列 (不连续)
-  [0, 2, 1, 3, 4] 
-  dp[1, 2, 2, 3, 4]
-   每次外层循环i的时候都需要再从0比较，所以两层for循环
-   nums[2]虽然没有nums[1]大，但是比nums[0]大，所以每次必须从头开始比
-   dp[i]代表包括i及小于之前的元素，删除所有比nums[i]大的之后递增子序列的长度（也就是nums删除之后的长度）
```js
var lengthOfLIS = function(nums) {
    let dp = new Array(nums.length).fill(1)
    let res = 1
    for(let i = 1; i < nums.length; i++) {
        for(let j = 0; j < i; j++) {
            // 只有当前元素大于前面元素的时候才会更新dp数组
            if(nums[i] > nums[j]) {
                dp[i] = Math.max(dp[i], dp[j] + 1)
            }
        }
        res = Math.max(dp[i], res)
    }
    return res
};
```

##  347 前k个高频元素
```js
let topKFrequent = function(nums, k) {
    let map = new Map()
    let arr = [...new Set(nums)]
    for(let item of nums) {
      if(map.has(item)) {
        map.set(item, map.get(item) + 1)
      }else {
        map.set(item, 1)
      }
    }
    return arr.sort((a, b) => map.get(b) - map.get(a)).slice(0, k)
};
```
