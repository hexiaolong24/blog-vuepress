---
title: 性能优化实际案例
date: 2021-07-02
sidebar: 'auto'
categories:
 - others
tags:
 - 前端
---

#   大方向
-   加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。
-   交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。
1.  减少 JavaScript 脚本执行时间,防抖、节流、web workers
2.  减少重绘重排，尽量直接合成， 避免强制同步布局，布局抖动


#  缩短白屏时间
-   第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。
-   第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。
-   第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。
##  减小包的体积
-   js压缩，html压缩去除空格注释，css压缩，减少RTT,比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件，通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT
-   按需引入第三方库
-   tree shaking
-   code split 分包（多入口，配置splitChunks，webpackChunkName配合动态引入实现路由懒加载）
-   externals将第三方库通过cdn链接的方式引入
-   dll分包技术，将第三方库单独不重复的打包
-   CSS 文件，媒体查询属性，拆分为多个不同的 CSS
-   图片压缩 image-webpack-loader

##  减少请求（1.1同域名下最多同时建立6个tcp长链接），增加同时请求
-   通过内联 JavaScript、内联 CSS 移除下载
-   随机cdn域名
-   升级http2
-   babel缓存，在`babel-loader`中开启`cacheDirectory: true`，hash: 每次wepack构建时会生成一个唯一的hash值。问题: 因为js和css同时使用一个hash值。 chunkhash：根据chunk生成的hash值。如果打包来源于同一个chunk，那么hash值就一样， 问题: js和css的hash值还是一样的，因为css是在js中被引入的，所以同属于一个chunk。contenthash: 根据文件的内容生成hash值。不同文件hash值一定不一样   

##  渲染阶段
-   JavaScript 标记上 async 或者 defer
-   尽量减少布局
-   使用flex布局
-   避免强制同步布局，操作样式之后立马读取样式
-   避免布局抖动
-   prefetch preload
-   服务端渲染ssr 预渲染
-   pwa
