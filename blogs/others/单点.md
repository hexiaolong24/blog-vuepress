---
title: 单点
date: 2021-07-02
sidebar: 'auto'
categories:
 - others
tags:
 - 前端
---

##  原型链
```js
function Foo() {
    getName = function(){ alert(1); };
    console.log(this)
    return this;
}
Foo.getName = function() { alert(2); };
Foo.prototype.getName = function(){ alert(3); };
var getName = function() { alert(4); };
function getName(){ alert(5); };

// Foo.getName(); // 2 先找自身
// getName(); // 4 虽然预解析的结果是函数，但实际调用的时候，会有赋值的过程
// Foo().getName(); // 1 函数内不申明变量，则会覆盖全局变量
// getName(); // 1 全局变量已被重新赋值
// new (Foo.getName)(); // 2
// (new Foo()).getName(); // 3 Foo的实例会沿着原型链找
```
##  变量提升
```js
showName() // 1
var showName = function () {
    console.log(2)
}

function showName() {
    console.log(1)
}
showName() // 2
```

##  作用域
```js
var bar = {
    myName: "time.geekbang.com",
    printName: function () {
        console.log(myName)
    }
}

function foo() {
    let myName = " 极客时间 "
    return bar.printName
}
let myName = " 极客邦 "
let _printName = foo()
_printName() // " 极客邦 "
bar.printName() // " 极客邦 "
```

```js
var a = 10;
function func1() {
  console.log(a) // 10
  a = 5
  console.log(window.a) // 5
}
func1()

var a = 10;
function func1() {
  console.log(a) // undefined
  a = 5
  console.log(window.a) // 10
  var a = 20;
  console.log(a) // 20
}
func1()
```

```js
var a = 20;
function bar() {
  console.log(a);
}
function foo(fn) {
  var a = 10;
  fn();
}
foo(bar);
// 20 
```

##  Promise
```js
Promise.resolve().then(() => {
  console.log(0)
  return Promise.resolve(1)
}).then(res => {
  console.log(res)
})

Promise.resolve().then(() => {
  console.log(2)
}).then(() => {
  console.log(3)
}).then(() => {
  console.log(4)
}).then(() => {
  console.log(5)
}).then(() => {
  console.log(6)
})
// 0 2 3 4 1 5 6
```

```js
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end');
}
async function async2() {
  console.log('async2 start');
}
console.log('script start');
setTimeout(function() {
  console.log('setTimeout');
}, 0);
async1();
new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2');
}).then(function() {
  console.log('promise3');
});
console.log('script end');
// script start  async1 start async2 start promise1 script end async1 end promise2 promise3 setTimeout
```

```js
async function a() {
  let c = 0
  let b = new Promise(r => {
    setTimeout(() => {
      let n = 1
      r(n)
    }, 0)
  })
  console.log('c1:' + c)
  await b.then(s => {
    c = s
  })
  console.log('c:' + c)
  return c
}
let w = a()
console.log('w:' + w)

// c1: 0
// w: [Object Promise]
// c: 1
```

```js
const promise = new Promise((resolve, reject) => {
  console.log(1);
  resolve(5);
  console.log(2);
}).then((res) => {
  console.log(res);
})

promise.then(() => {
  console.log(3);
})

console.log(4)

setTimeout(() => {
  console.log(6)
})
// 1 2 4 5 3 6
```

##  值传递
```js
// 引用数据类型也是值传递（值是引用地址）
var arr = [12, 23]
function fn(arr) {
  console.log(arr) // [12, 23]
  arr[0] = 100
  arr = [100]
  arr[0] = 0
  console.log(arr) // [0]
}
fn(arr)
console.log(arr) // [100, 23]
```

##  闭包
```js
function print(n){
    for(var i = 0;i <n;i++){
        setTimeout(console.log, 1000, i);
    }
}
print(5);
// 0 1 2 3 4 
```
改成每隔一秒输出一个数字
```js
async function print(n){
    for(var i = 0;i <n;i++){
        await wait()
        // setTimeout(console.log, 0, i);
        console.log(i)
    }
}
print(5);
function wait() {
  return new Promise(resolve => {
    setTimeout(resolve, 1000)
  })
}
```
promise
```js
function print(i, n){
  if(i < n) {
    new Promise(resolve => {
      setTimeout(resolve, 1000)
    }).then(() => {
      setTimeout(console.log, 0, i)
      i++
      print(i, n)
    })
  }
}
print(0, 5);
```

```js
function bar() {
  var a = 20;
  return function() {
    console.log(a);
  }
}


var foo = bar();
var a = 10;
foo();  
// 20 
```