---
title: vite
date: 2020-10-29
sidebar: "auto"
categories:
  - vite
tags:
  - vite
---

## plugin 分类

- 通用的 rollup
- 独有的

### 通用的 7 个

- options
  这是构建阶段的第一个钩子，通常用于插件开发中的参数阅读选项

```js
// 当名为myPlugin的插件生效时，给它传递的参数便可以在该插件源码中的 options 钩子函数中获取到
myPlugin({
  name: "name",
  age: 18,
});
```

- buildStart
  这是构建阶段的第二个钩子，读取到入口文件后开始构建。
  自定义任务：你可以在构建开始前执行自定义任务，例如清理临时文件、生成一些构建配置、执行前置操作等。
  日志记录：你可以在构建开始前添加一些日志记录，以记录构建过程的开始时间、项目信息等，以便后续分析和调试。
  状态检查：在构建开始前，你可以执行一些状态检查，确保构建所需的条件满足，如果有问题，可以提前终止构建并给出错误提示。
  设置环境变量：你可以在构建开始前设置一些环境变量，以影响构建过程中的行为，例如根据不同的环境配置不同的构建选项。

- resolveId
  主要用于自定义模块解析的行为

- load
  执行时间点：在模块加载时

- transform
  执行时间点：在模块代码构建期间。

- buildEnd
  buildEnd 钩子函数在 Vite 构建结束后触发。使用场景：你可以使用 buildEnd 钩子来执行一些与构建结束相关的操作，例如生成构建报告、自动化部署、通知团队构建已完成等。这个钩子通常用于处理构建后的事务。
- closeBundle 作用：closeBundle 钩子函数在 Vite 打包生成 bundle 文件时触发。
  你可以使用 closeBundle 钩子来执行一些与打包后的 bundle 文件相关的操作，例如自动化地上传 bundle 文件到 CDN、生成版本号、进行代码压缩或加密等。这个钩子通常用于处理 bundle 文件的后续处理。

### 独有的钩子 6 个

- config： 允许你在 Vite 配置对象被创建之前对其进行修改和扩展
- configResolved： 用于在 Vite 配置对象被解析和应用后执行自定义操作。这个钩子函数在配置加载过程的较早阶段触发，允许你检查和修改已解析的 Vite 配置。
- configureServer： 用于配置开发服务器。这个钩子函数在 Vite 开发服务器启动之前执行，允许你自定义开发服务器的行为
- configurePreviewServer： 与 configureServer 相同，但用于预览服务器。
- transformIndexHtml： 允许你在构建过程中修改生成的 HTML 文件。这个钩子函数在生成最终的 index.html 文件之前执行，允许你自定义 HTML 内容或添加额外的标签、脚本等。
- handleHotUpdate： 用于在模块发生热更新（Hot Module Replacement，HMR）时执行自定义逻辑。

## 构建原理

- 需要打包工具的核心原理是浏览器在执行代码时没有办法读懂文件的依赖关系，同时无法处理非 js 的文件类型
- 在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。

### 可以实现的原因

- 浏览器开始支持原生 ES 模块化
- 越来越多的 js 工具开始使用编译型语言编写

### 启动原理

Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。

- 依赖： 大多为在开发时不会变动的纯 JavaScript。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 ESM 或者 CommonJS）。
  Vite 将会使用 esbuild 预构建依赖。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。

- 源码：通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。
  Vite 以 原生 ESM 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。

### 预构建

当你首次启动 vite 时，Vite 在本地加载你的站点之前预构建了项目依赖。默认情况下，它是自动且透明地完成的。
依赖预构建仅适用于开发模式，并使用 esbuild 将依赖项转换为 ES 模块。在生产构建中，将使用 @rollup/plugin-commonjs

- 两个目的

1.  CommonJS 和 UMD 兼容性: 在开发阶段中，Vite 的开发服务器将所有代码视为原生 ES 模块。因此，Vite 必须先将以 CommonJS 或 UMD 形式提供的依赖项转换为 ES 模块。
2.  性能： 为了提高后续页面的加载性能，Vite 将那些具有许多内部模块的 ESM 依赖项转换为单个模块（多个请求合成一个请求）
    有些包将它们的 ES 模块构建为许多单独的文件，彼此导入。例如，lodash-es 有超过 600 个内置模块！当我们执行 import { debounce } from 'lodash-es' 时，浏览器同时发出 600 多个 HTTP 请求！即使服务器能够轻松处理它们，但大量请求会导致浏览器端的网络拥塞，使页面加载变得明显缓慢。

- 缓存

1.  文件系统的缓存

- Vite 将预构建的依赖项缓存到 node_modules/.vite 中，依据以下条件决定是否重新执行
  - 包管理器的锁文件内容，例如 package-lock.json，yarn.lock，pnpm-lock.yaml，或者 bun.lockb；
  - 补丁文件夹的修改时间；
  - vite.config.js 中的相关字段；
  - NODE_ENV 的值。
- 手动重新执行
  - --force 选项
  - 或手动删除 node_modules/.vite 缓存目录

2.  浏览器缓存

- 已预构建的依赖请求使用 HTTP 头 max-age=31536000, immutable 进行强缓存
  - 通过浏览器开发工具的 Network 选项卡暂时禁用缓存；
  - 重启 Vite 开发服务器指定 --force 选项，来重新构建依赖项;
  - 重新载入页面。

### 更新原理

- webpack 的问题：

1.  基于打包启动时，当源文件被修改后，重新构建整个包是低效的，原因显而易见：更新速度会随着应用体积的增加而线性下降。
2.  虽然有 hmr，这样它们只需要在文件更改时使模块图的一部分失活，但它也仍需要整个重新构建并重载页面

- vite 的优势

1.  在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活（大多数时候只是模块本身），使得无论应用大小如何，HMR 始终能保持快速更新。
2.  Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。

### 为什么生产环境还需要打包

- 嵌套导入会带来额外的 http 网络往返
- 生产环境还是需要使用 tree-shaking 懒加载 chunk 分包（更好的缓存）

尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。

### 为何不用 ESBuild

- Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容
  尽管 esbuild 速度更快，但 Vite 采用了 Rollup 灵活的插件 API 和基础建设，这对 Vite 在生态中的成功起到了重要作用。目前来看，我们认为 Rollup 提供了更好的性能与灵活性方面的权衡。
- Rollup 已经开始着手改进性能,同时还有一个正在进行中的工作，即构建一个名为 Rolldown 的 Rust 版本的 Rollup。
  一旦 Rolldown 准备就绪，它就可以在 Vite 中取代 Rollup 和 esbuild，显著提高构建性能，并消除开发和构建之间的不一致性。你可以观看 Evan You 在 ViteConf 2023 的主题演讲 了解更多细节。
