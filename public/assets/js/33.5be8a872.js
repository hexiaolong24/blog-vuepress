(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{534:function(t,a,s){"use strict";s.r(a);var r=s(4),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"堆-栈"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#堆-栈"}},[t._v("#")]),t._v(" 堆 & 栈")]),t._v(" "),s("h3",{attrs:{id:"误区"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#误区"}},[t._v("#")]),t._v(" 误区")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("js内存其实只有一个堆内存，平时我们经常说是栈内存和堆内存，其实栈内存准确的说应该是栈数据结构内存，它只是堆内存的一块分区，他们保存的数据是不一样的")])]),t._v(" "),s("li",[s("p",[t._v("js引擎不允许我们直接操作堆内存，访问堆内存要先找到栈内存中对应的变量")])])]),t._v(" "),s("h3",{attrs:{id:"相同点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#相同点"}},[t._v("#")]),t._v(" 相同点")]),t._v(" "),s("ul",[s("li",[t._v("他们的相同点是都是内存，临时存储")])]),t._v(" "),s("h3",{attrs:{id:"不同"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#不同"}},[t._v("#")]),t._v(" 不同")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("栈内存空间小，保存变量和基本数据类型的值，栈内存程序执行完就会释放，全局代码（关闭浏览器释放），函数代码（函数执行完就释放")])]),t._v(" "),s("li",[s("p",[t._v("堆内存空间相对较大，保存引用数据类型的值，而堆内存是通过垃圾回收机制定期去回收，所以栈内存的空间利用率高，因为释放内存的效率高")])])]),t._v(" "),s("h3",{attrs:{id:"内存管理三部曲"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#内存管理三部曲"}},[t._v("#")]),t._v(" 内存管理三部曲")]),t._v(" "),s("ul",[s("li",[t._v("分配内存")]),t._v(" "),s("li",[t._v("使用内存")]),t._v(" "),s("li",[t._v("释放内存")])]),t._v(" "),s("h3",{attrs:{id:"小插曲"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#小插曲"}},[t._v("#")]),t._v(" 小插曲")]),t._v(" "),s("ul",[s("li",[t._v("说一个比较有意思的点，比如我们var a =1 ,那么这个a其实是保存在堆内存中的，一般都会很自然的认为他是存在于栈内存中，原因如下：其实是window.a = 1，在全局的申明的变量其实都添加到window中，window 这个全局变量是保存在栈内存中，而他所指的对象是保存在堆内存中的，那这样说是不是就栈内存中就只有window了，其实不是的，预知后事如何，请看执行上下文、作用域相关内容")])])])}),[],!1,null,null,null);a.default=v.exports}}]);