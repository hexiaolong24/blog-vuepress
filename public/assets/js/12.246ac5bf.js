(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{487:function(t,e,s){"use strict";s.r(e);var v=s(4),a=Object(v.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"原生dom事件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#原生dom事件"}},[t._v("#")]),t._v(" 原生DOM事件")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("绑定事件监听：事件名，回调函数")])]),t._v(" "),s("li",[s("p",[t._v("用户操作触发事件：（event）事件名，当用户对标签元素的界面做特定操作时，浏览器会自动分发对应名称的事件，并传递event")])])]),t._v(" "),s("h2",{attrs:{id:"自定义事件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#自定义事件"}},[t._v("#")]),t._v(" 自定义事件")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("绑定事件监听：事件名，回调函数，通过形参接受数据，在函数体处理数据")])]),t._v(" "),s("li",[s("p",[t._v("触发/分发事件：事件名，数据")])])]),t._v(" "),s("h2",{attrs:{id:"react-中的pubsub，vue中的自定义事件，事件总线机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-中的pubsub，vue中的自定义事件，事件总线机制"}},[t._v("#")]),t._v(" React 中的pubsub，Vue中的自定义事件，事件总线机制")]),t._v(" "),s("p",[t._v("vue中的自定义事件是给谁绑定，谁才能分发事件，可以替代子传父的函数传参，1 可以通过标签属性的形式自定义事件名，2 第二种是可以在父组件中通过ref属性找到子组件，在父组件的mounted生命周期钩子中给子组件绑定事件，在子组件中通过this.$emit('事件名'，data)分发事件，这就是为什么会有事件总线机制，因为自定义事件只能子传父，受this 指向的影响，从vue源码中我们可以看到$on的方法第一步就是缓存this")]),t._v(" "),s("p",[t._v("事件总线机制是创建一个vm对象，并挂载到vue的原型对象上，所有的组件对象都可以访问到，我们知道$on 和$emit其实是在Vue的原型对象上的方法，那么为什么不能在各个组件中直接通过this来绑定，分发事件，其实是可以访问到这个方法的，但是由于this的指向不同，最终导致没有绑定上，所以需要先创建一个vm对象挂载到vue的原型上，我们都叫这个对象是事件总线对象，我个人认为这个说法是不准确的，事件总线对象是包括所有自定义事件的一个对象，当我们自定义实现vue事件总线机制的时候，需要创建两个对象，一个是向外暴露的对象，提供$on $emit $off 这些方法，一个是事件总线对象，将各种自定义事件作为属性保存起来，每个属性值是数组结构，而pubsub中的都是对象结构，所以说新创建的这个vm对象其实是向外暴露这个方法的对象，这里就能说明为什么必须要用vm，因为vm对象是vue的实例对象，沿着原型链找同样可以找到这些方法，同时也解决了 this指向的问题。")])])}),[],!1,null,null,null);e.default=a.exports}}]);