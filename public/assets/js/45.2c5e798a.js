(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{546:function(t,a,s){"use strict";s.r(a);var r=s(4),v=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"闭包的生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包的生命周期"}},[t._v("#")]),t._v(" 闭包的生命周期")]),t._v(" "),s("ul",[s("li",[t._v("产生：1 函数嵌套，2 内部函数引用外部函数的局部变量（当然前提是你要调用内部函数）")]),t._v(" "),s("li",[t._v("死亡：在内部函数成为垃圾对象时")])]),t._v(" "),s("h2",{attrs:{id:"作用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#作用"}},[t._v("#")]),t._v(" 作用")]),t._v(" "),s("ol",[s("li",[t._v("延长外部函数局部变量对象的生命周期，通常我们会认为是延长了局部变量的生命周期，其实应该是整个变量对象的生命周期，这个稍后我会阐述一下")]),t._v(" "),s("li",[t._v("就是可以在外部访问到函数内部的局部变量（通常由于作用域的原因，我们是无法正常在外部访问到函数的局部变量的，但是利用闭包就可以，简单说就是函数内部又嵌套了一个函数，内部函数引用到了外部函数的局部变量，返回这个内部函数，我们在外部直接调用内部函数就间接的使用到了函数内部的局部变量）")])]),t._v(" "),s("h2",{attrs:{id:"缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),s("ul",[s("li",[t._v("不及时清除会长期占用内存空间，过多使用闭包容易造成内存溢出")])]),t._v(" "),s("h2",{attrs:{id:"使用场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),s("ul",[s("li",[t._v("在函数外部需要操作函数内部的局部变量")]),t._v(" "),s("li",[t._v("封装js功能库")]),t._v(" "),s("li",[t._v("react和vue中在组件的生命周期函数，用到的局部变量是this，我们知道在生命周期函数中的this是指当前的实例对象，这里的this肯定用到了闭包，其实各大功能库的函数中经常会在进去函数之前做一步缓存this的操作，这个其实就用到了闭包，比如 Vue 的事件总线机制中，$on,$emit,$off这三个方法就用到了")])]),t._v(" "),s("h2",{attrs:{id:"闭包到底是什么？（以下观点纯属个人扯淡）"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#闭包到底是什么？（以下观点纯属个人扯淡）"}},[t._v("#")]),t._v(" 闭包到底是什么？（以下观点纯属个人扯淡）")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("闭包到底是什么？很多人讲闭包其实就是内部函数，因为内部函数用到了这个变量，这个变量保存在闭包中，所以闭包是内部函数，其实准确来说这是不正确的，还有人认为闭包是一个对象，里面有key-value的键值对，保存着内部函数使用的这个变量，其实这个较真来说也是不正确的，因为我们知道对象中永远不会保存着另一个对象本身，对吧，它保存另一个对象的方式其实是一个引用地址，这个地址指向堆内存中的一个对象")])]),t._v(" "),s("li",[s("p",[t._v("所以，闭包准确来说应该是在内部函数的内存中存储的一个引用地址，这个引用地址指向内部函数使用外部局部变量所在的那个变量对象，通常我们会认为闭包会延长局部变量的生命周期，但其实他会延长整个外部函数的变量对象的生命周期，因为这个引用地址指向的是整个对象，既然一个对象有被指向，那么这个对象肯定不会成为垃圾对象，但是如果我们用Chrome调试查看的话，会发现外部函数的变量对象中只会留下内部函数使用到的变量，并不是什么都有，这只不过是浏览器为了性能优化将不使用的变量从变量对象中清除掉了")])]),t._v(" "),s("li",[s("p",[t._v("有兴趣可以用Chrome调试，里面有一个memory的模块，可以清楚的看到不同阶段当前浏览器所占用的内存大小，如果你在外部函数中写了一个很大的for循环，将每一项放入一个数组中，但是内部函数不用这个数组，只用到了外部函数的一个局部变量a，很明显的可以看出在进入内部函数后，浏览器所占的内存空间减小了非常多，这也就能证明，确实是浏览器为了性能优化，将不使用的变量直接从这个变量对象中清除了")])]),t._v(" "),s("li",[s("p",[t._v("所以整体来看，闭包其实也是沿着作用域链来查找变量的，为什么必须要外部函数嵌套内部函数，如果是兄弟关系的函数，肯定不会产生闭包，因为首先从作用域链这他们就不会产生联系，所以本质还是查找变量这一套东西，只不过是一个新的说法，当有函数嵌套，内部函数使用外部函数的局部变量就出现了闭包，其实本质上我个人觉得和一个函数要用到全局的一个变量，沿着作用域链找，如果自身没有，找到全局作用域是一个道理")])])])])}),[],!1,null,null,null);a.default=v.exports}}]);