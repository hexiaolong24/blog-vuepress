(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{532:function(t,v,_){"use strict";_.r(v);var r=_(4),e=Object(r.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"for-in-for-of"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#for-in-for-of"}},[t._v("#")]),t._v(" for in&for of")]),t._v(" "),_("ol",[_("li",[t._v("for of 只能遍历可迭代对象，获取的是迭代器返回的value值（...运算符同样只能作用在具有iterator接口的可迭代对象上）")])]),t._v(" "),_("ul",[_("li",[t._v("Array")]),t._v(" "),_("li",[t._v("arguments")]),t._v(" "),_("li",[t._v("string")]),t._v(" "),_("li",[t._v("set")]),t._v(" "),_("li",[t._v("map")])]),t._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[_("p",[t._v("for in 遍历数组返回的是索引下标，遍历对象返回的是属性key,不仅枚举自身属性，还会枚举其原型上的属性")])]),t._v(" "),_("li",[_("p",[t._v("for in 不能遍历set，但可以遍历其他伪数组，返回索引下标，也可以遍历字符串，返回的是value")])])]),t._v(" "),_("h2",{attrs:{id:"三点运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三点运算符"}},[t._v("#")]),t._v(" 三点运算符")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("可以直接对数组进行遍历取值，不能直接作用在对象，是ES9中加入了，"),_("code",[t._v("{...obj}")]),t._v("相当于是浅拷贝，返回的是一个对象，在"),_("code",[t._v("react")]),t._v("中给标签属性传参的时候可以这样写，我们都知道"),_("code",[t._v("react")]),t._v("中写js代码需要用"),_("code",[t._v("{}")]),t._v("括起来，但是写这个语法的时候只写一个括号就可以，但实际上是外边还应该再有一个"),_("code",[t._v("{}")]),t._v("的，同样在小程序开发中作为标签属性传参的时候也是\n"),_("code",[t._v("{{")]),t._v(" ...item "),_("code",[t._v("}}")]),t._v("这样传参，但是小程序本身也是要用两个大括号括起来，看起来也相当于少了一个"),_("code",[t._v("{}")])])]),t._v(" "),_("li",[_("p",[t._v("第一个使用场景，函数调用传参的时候，相当于是拆包")])]),t._v(" "),_("li",[_("p",[t._v("第二个使用场景是函数接受参数的时候，当接收的参数不固定的时候，就可以用三点运算符，相当于是打包的过程")])])])])}),[],!1,null,null,null);v.default=e.exports}}]);